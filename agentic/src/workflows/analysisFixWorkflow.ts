import { type MessagesAnnotation } from "@langchain/langgraph";
import { AIMessage, AIMessageChunk } from "@langchain/core/messages";
import { CompiledStateGraph, END, START, StateGraph } from "@langchain/langgraph";

import {
  KaiUserInteractionMessage,
  KaiWorkflowMessageType,
  type PendingUserInteraction,
  type KaiWorkflow,
  type KaiWorkflowInitOptions,
  type KaiWorkflowInput,
  type KaiWorkflowMessage,
  type KaiWorkflowResponse,
} from "../types";
import {
  AdditionalInfoSummarizeOutputState,
  AddressAdditionalInfoOutputState,
  AnalysisIssueFixRouterState,
  AnalysisIssueFixOverallState,
} from "../schemas/analysisIssueFix";
import { modelHealthCheck } from "../utils";
import { FileSystemTools } from "../tools/filesystem";
import { KaiWorkflowEventEmitter } from "../eventEmitter";
import { AnalysisIssueFix } from "../nodes/analysisIssueFix";
import { EnhancedIncident } from "../../../shared/dist/types";

export interface AnalysisIssueFixWorkflowInput extends KaiWorkflowInput {
  programmingLanguage: string;
  migrationHint: string;
}

/**
 * Agentic workflow that takes a list of incidents as input
 * and fixes all incidents as well as addresses any additional
 * changes needed elsewhere in the project. The workflow works
 * as follows - first, it iterates over all incidents grouped
 * by files and generates fixes using the analysis fix node
 * second, it captures output generated by the analysis fix node
 * and passes it to summarize node that summarizes any further
 * changes needed. finally, this output is passed to the node
 * that addresses these additional changes. In future, there
 * will be continuation to this to address new issues brought up
 * by the task manager.
 */
export class AnalysisIssueFixWorkflow
  extends KaiWorkflowEventEmitter
  implements KaiWorkflow<AnalysisIssueFixWorkflowInput>
{
  private workflow: CompiledStateGraph<any, any, string, any, any, any> | undefined;
  private userInteractionPromises: Map<string, PendingUserInteraction>;

  constructor() {
    super();
    this.workflow = undefined;
    this.userInteractionPromises = new Map<string, PendingUserInteraction>();

    this.runToolsEdge = this.runToolsEdge.bind(this);
    this.processUserInputEdge = this.processUserInputEdge.bind(this);
    this.analysisIssueFixRouterEdge = this.analysisIssueFixRouterEdge.bind(this);
  }

  async init(options: KaiWorkflowInitOptions): Promise<void> {
    const fsTools = new FileSystemTools(options.workspaceDir, options.fsCache);
    const { supportsTools, connected, supportsToolsInStreaming } = await modelHealthCheck(
      options.model,
    );
    if (!connected) {
      throw Error(`Provided model doesn't seem to have connection`);
    }
    const analysisIssueFixNodes = new AnalysisIssueFix(
      {
        model: options.model,
        toolsSupported: supportsTools,
        toolsSupportedInStreaming: supportsToolsInStreaming,
      },
      fsTools.all(),
      options.fsCache,
    );

    // relay events from nodes back to callers
    analysisIssueFixNodes.on("workflowMessage", (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });
    fsTools.on("workflowMessage", (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });

    const workflow = new StateGraph({
      input: AnalysisIssueFixRouterState,
      output: AddressAdditionalInfoOutputState,
      stateSchema: AnalysisIssueFixOverallState,
    })
      .addNode("fix_analysis_issue_router", analysisIssueFixNodes.fixAnalysisIssueRouter)
      .addNode("fix_analysis_issue", analysisIssueFixNodes.fixAnalysisIssue)
      .addNode(
        "summarize_additional_information",
        analysisIssueFixNodes.summarizeAdditionalInformation,
      )
      .addNode("address_additional_information", analysisIssueFixNodes.addressAdditionalInformation)
      .addNode("run_tools", analysisIssueFixNodes.runTools)
      .addEdge(START, "fix_analysis_issue_router")
      // router loops over all incidents and decides when to go to additional info
      .addConditionalEdges("fix_analysis_issue_router", this.analysisIssueFixRouterEdge, [
        "fix_analysis_issue",
        "summarize_additional_information",
        "fix_analysis_issue_router",
        END,
      ])
      // go back to router with response, router decides what to do next
      .addEdge("fix_analysis_issue", "fix_analysis_issue_router")
      // we only address additional information after user confirmation
      .addConditionalEdges("summarize_additional_information", this.processUserInputEdge, [
        "address_additional_information",
        END,
      ])
      .addEdge("run_tools", "address_additional_information")
      .addConditionalEdges("address_additional_information", this.runToolsEdge, ["run_tools", END])
      .compile();
    this.workflow = workflow;
  }

  // edge responsible for invoking analysis issue fix node until all issues
  // are resolved. when resolved, moves onto addressing additional information
  async analysisIssueFixRouterEdge(
    state: typeof AnalysisIssueFixRouterState.State,
  ): Promise<string> {
    // if these attributes are available, router meant to solve the analysis issue
    if (state.fileContent && state.fileUri && state.incidentsDescription) {
      return "fix_analysis_issue";
    }
    // if there was a response, router needs to accumulate it
    if (state.response) {
      return "fix_analysis_issue_router";
    }
    // if there were any errors earlier in the router, go back to router
    // this will make router pick up the next incident in list
    if (
      state.currentIdx < state.incidentsByUris.length &&
      (!state.fileContent || !state.fileUri || !state.incidentsDescription)
    ) {
      return "fix_analysis_issue_router";
    }
    // if the router accumulated all responses, we need to go to additional information
    if (state.previousResponse) {
      return "summarize_additional_information";
    }
    return "END";
  }

  async run(input: AnalysisIssueFixWorkflowInput): Promise<KaiWorkflowResponse> {
    if (!this.workflow || !(this.workflow instanceof CompiledStateGraph)) {
      throw new Error(`Workflow must be inited before it can be run`);
    }

    const incidentsByUris: { uri: string; incidents: EnhancedIncident[] }[] =
      input.incidents?.reduce(
        (acc, incident) => {
          const existingEntry = acc.find(
            (entry) => entry.uri === incident.uri.replace("file://", ""),
          );
          if (existingEntry) {
            existingEntry.incidents.push(incident);
          } else {
            acc.push({
              uri: incident.uri.replace("file://", ""),
              incidents: [incident],
            });
          }
          return acc;
        },
        [] as Array<{ uri: string; incidents: EnhancedIncident[] }>,
      ) ?? [];

    const graphInput: typeof AnalysisIssueFixRouterState.State = {
      incidentsByUris,
      currentIdx: 0,
      allResponses: [],
      migrationHint: input.migrationHint,
      programmingLanguage: input.programmingLanguage,
      // internal fields
      fileContent: undefined,
      fileUri: undefined,
      incidentsDescription: undefined,
      previousResponse: undefined,
      response: undefined,
    };

    const outputState: typeof AnalysisIssueFixOverallState.State = await this.workflow.invoke(
      graphInput,
      {
        recursionLimit: incidentsByUris.length + 50,
      },
    );

    return {
      errors: [],
      modified_files: outputState.modifiedFiles,
    };
  }

  async resolveUserInteraction(response: KaiUserInteractionMessage): Promise<void> {
    const promise = this.userInteractionPromises.get(response.id);
    if (!promise) {
      return;
    }
    const { data } = response;
    if (!data.response || (!data.response.choice && data.response.yesNo === undefined)) {
      promise.reject(Error(`Invalid response from user`));
    }
    promise.resolve(response);
  }

  private async processUserInputEdge(state: typeof AdditionalInfoSummarizeOutputState.State) {
    let nextState = "END";
    if (state.additionalInformation !== "" && !state.additionalInformation.includes("NO-CHANGE")) {
      const id = `res-${Date.now()}`;
      const userInteractionPromise = new Promise<KaiUserInteractionMessage>((resolve, reject) => {
        this.userInteractionPromises.set(id, {
          resolve,
          reject,
        });
      });
      this.emitWorkflowMessage({
        id,
        type: KaiWorkflowMessageType.UserInteraction,
        data: {
          type: "yesNo",
          systemMessage: {
            yesNo:
              "We found more issues that we think we can fix. Do you want me to continue fixing those?",
          },
        },
      });
      try {
        const userResponse = await userInteractionPromise;
        if (userResponse.data.response?.yesNo) {
          nextState = "address_additional_information";
        }
      } catch (e) {
        console.log(`Failed to wait for user response - ${e}`);
      } finally {
        this.userInteractionPromises.delete(id);
      }
    }
    return nextState;
  }

  private runToolsEdge(state: typeof MessagesAnnotation.State) {
    const lastMessage = state.messages[state.messages.length - 1];
    if (lastMessage instanceof AIMessage || lastMessage instanceof AIMessageChunk) {
      return lastMessage.tool_calls && lastMessage.tool_calls.length > 0 ? "run_tools" : END;
    } else {
      return END;
    }
  }
}
