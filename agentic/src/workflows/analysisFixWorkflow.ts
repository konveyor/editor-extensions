import { Annotation, type MessagesAnnotation } from "@langchain/langgraph";
import { AIMessage, AIMessageChunk } from "@langchain/core/messages";
import { CompiledStateGraph, END, START, StateGraph } from "@langchain/langgraph";

import {
  KaiUserInteractionMessage,
  KaiWorkflowMessageType,
  type PendingUserInteraction,
  type KaiWorkflow,
  type KaiWorkflowInitOptions,
  type KaiWorkflowInput,
  type KaiWorkflowMessage,
  type KaiWorkflowResponse,
} from "../types";
import {
  AdditionalInfoSummarizeOutputState,
  AnalysisIssueFixRouterState,
  AnalysisIssueFixOverallState,
} from "../schemas/analysisIssueFix";
import { modelHealthCheck } from "../utils";
import { FileSystemTools } from "../tools/filesystem";
import { KaiWorkflowEventEmitter } from "../eventEmitter";
import { AnalysisIssueFix } from "../nodes/analysisIssueFix";
import { EnhancedIncident } from "../../../shared/dist/types";
import { DiagnosticsOverallState } from "../schemas/diagnosticsIssueFix";
import { DiagnosticsIssueFix } from "../nodes/diagnosticsIssueFix";

export interface AnalysisIssueFixWorkflowInput extends KaiWorkflowInput {
  programmingLanguage: string;
  migrationHint: string;
}

const CompositeState = Annotation.Root({
  ...DiagnosticsOverallState.spec,
  ...AnalysisIssueFixOverallState.spec,
});

/**
 * Agentic workflow that takes a list of incidents as input
 * and fixes all incidents as well as addresses any additional
 * changes needed elsewhere in the project. The workflow works
 * as follows - first, it iterates over all incidents grouped
 * by files and generates fixes using the analysis fix node
 * second, it captures output generated by the analysis fix node
 * and passes it to summarize node that summarizes any further
 * changes needed. third, this output is passed to the node
 * that addresses these additional changes. finally, the flow
 * waits for any additional changes from task manager and fixes
 * them using a planner agent and a collection of sub-agents
 */
export class KaiInteractiveWorkflow
  extends KaiWorkflowEventEmitter
  implements KaiWorkflow<AnalysisIssueFixWorkflowInput>
{
  private workflow: CompiledStateGraph<any, any, string, any, any, any> | undefined;
  private userInteractionPromises: Map<string, PendingUserInteraction>;

  constructor() {
    super();
    this.workflow = undefined;
    this.userInteractionPromises = new Map<string, PendingUserInteraction>();

    this.runToolsAdditionalInfoEdge = this.runToolsAdditionalInfoEdge.bind(this);
    this.processAdditionalInfoUserInputEdge = this.processAdditionalInfoUserInputEdge.bind(this);
    this.analysisIssueFixRouterEdge = this.analysisIssueFixRouterEdge.bind(this);
  }

  async init(options: KaiWorkflowInitOptions): Promise<void> {
    const fsTools = new FileSystemTools(options.workspaceDir, options.fsCache);
    const { supportsTools, connected, supportsToolsInStreaming } = await modelHealthCheck(
      options.model,
    );
    if (!connected) {
      throw Error(`Provided model doesn't seem to have connection`);
    }
    const analysisIssueFixNodes = new AnalysisIssueFix(
      {
        model: options.model,
        toolsSupported: supportsTools,
        toolsSupportedInStreaming: supportsToolsInStreaming,
      },
      fsTools.all(),
      options.fsCache,
    );

    const diagnosticsFixNodes = new DiagnosticsIssueFix(
      {
        model: options.model,
        toolsSupported: supportsTools,
        toolsSupportedInStreaming: supportsToolsInStreaming,
      },
      fsTools.all(),
      [],
      options.fsCache,
    );

    // relay events from nodes back to callers
    analysisIssueFixNodes.on("workflowMessage", (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });
    fsTools.on("workflowMessage", (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });

    const workflow = new StateGraph({
      input: AnalysisIssueFixRouterState,
      output: CompositeState,
      stateSchema: CompositeState,
    })
      .addNode("fix_analysis_issue_router", analysisIssueFixNodes.fixAnalysisIssueRouter)
      .addNode("fix_analysis_issue", analysisIssueFixNodes.fixAnalysisIssue)
      .addNode(
        "summarize_additional_information",
        analysisIssueFixNodes.summarizeAdditionalInformation,
      )
      .addNode("summarize_history", analysisIssueFixNodes.summarizeHistory)
      .addNode("address_additional_information", analysisIssueFixNodes.addressAdditionalInformation)
      .addNode("run_tools_additional_info", analysisIssueFixNodes.runTools)
      .addEdge(START, "fix_analysis_issue_router")
      // router loops over all incidents and decides when to go to additional info
      .addConditionalEdges("fix_analysis_issue_router", this.analysisIssueFixRouterEdge, [
        "fix_analysis_issue",
        "summarize_additional_information",
        "summarize_history",
        "fix_analysis_issue_router",
        END,
      ])
      // go back to router with response, router decides what to do next
      .addEdge("fix_analysis_issue", "fix_analysis_issue_router")
      // we only address additional information after user confirmation
      .addConditionalEdges(
        "summarize_additional_information",
        this.processAdditionalInfoUserInputEdge,
        ["address_additional_information", END],
      )
      .addEdge("run_tools_additional_info", "address_additional_information")
      .addConditionalEdges("address_additional_information", this.runToolsAdditionalInfoEdge, [
        "run_tools_additional_info",
        END,
      ])
      .compile();
    this.workflow = workflow;
  }

  // edge responsible for invoking analysis issue fix node until all issues
  // are resolved. when resolved, moves onto addressing additional information
  async analysisIssueFixRouterEdge(
    state: typeof AnalysisIssueFixRouterState.State,
  ): Promise<string | string[]> {
    // if these attributes are available, router meant to solve the analysis issue
    if (state.inputFileContent && state.inputFileUri && state.inputIncidentsDescription) {
      return "fix_analysis_issue";
    }
    // if there was a response, router needs to accumulate it
    if (state.outputUpdatedFile && state.outputUpdatedFileUri) {
      return "fix_analysis_issue_router";
    }
    // if there were any errors earlier in the router, go back to router
    // this will make router pick up the next incident in list
    if (
      state.currentIdx < state.inputIncidentsByUris.length &&
      (!state.inputFileContent || !state.inputFileUri || !state.inputIncidentsDescription)
    ) {
      return "fix_analysis_issue_router";
    }
    // if the router accumulated all responses, we need to go to additional information
    if (state.inputAllAdditionalInfo && state.inputAllReasoning) {
      return ["summarize_additional_information", "summarize_history"];
    } else if (state.inputAllAdditionalInfo) {
      return "summarize_additional_information";
    }
    return "END";
  }

  async run(input: AnalysisIssueFixWorkflowInput): Promise<KaiWorkflowResponse> {
    if (!this.workflow || !(this.workflow instanceof CompiledStateGraph)) {
      throw new Error(`Workflow must be inited before it can be run`);
    }

    const incidentsByUris: { uri: string; incidents: EnhancedIncident[] }[] =
      input.incidents?.reduce(
        (acc, incident) => {
          const existingEntry = acc.find(
            (entry) => entry.uri === incident.uri.replace("file://", ""),
          );
          if (existingEntry) {
            existingEntry.incidents.push(incident);
          } else {
            acc.push({
              uri: incident.uri.replace("file://", ""),
              incidents: [incident],
            });
          }
          return acc;
        },
        [] as Array<{ uri: string; incidents: EnhancedIncident[] }>,
      ) ?? [];

    const graphInput: typeof AnalysisIssueFixRouterState.State = {
      inputIncidentsByUris: incidentsByUris,
      currentIdx: 0,
      outputAllResponses: [],
      migrationHint: input.migrationHint,
      programmingLanguage: input.programmingLanguage,
      // internal fields
      inputFileContent: undefined,
      inputFileUri: undefined,
      inputIncidentsDescription: undefined,
      inputAllAdditionalInfo: undefined,
      inputAllFileUris: undefined,
      inputAllReasoning: undefined,
      outputAdditionalInfo: undefined,
      outputReasoning: undefined,
      outputUpdatedFile: undefined,
      outputUpdatedFileUri: undefined,
    };

    const outputState: typeof AnalysisIssueFixOverallState.State = await this.workflow.invoke(
      graphInput,
      {
        // additional 50 iterations on top of the base analysis issues
        recursionLimit: incidentsByUris.length + 50,
      },
    );

    return {
      errors: [],
      modified_files: outputState.outputModifiedFiles,
    };
  }

  async resolveUserInteraction(response: KaiUserInteractionMessage): Promise<void> {
    const promise = this.userInteractionPromises.get(response.id);
    if (!promise) {
      return;
    }
    const { data } = response;
    if (!data.response || (!data.response.choice && data.response.yesNo === undefined)) {
      promise.reject(Error(`Invalid response from user`));
    }
    promise.resolve(response);
  }

  private async processAdditionalInfoUserInputEdge(
    state: typeof AdditionalInfoSummarizeOutputState.State,
  ): Promise<string> {
    let nextNode = END;
    if (
      state.summarizedAdditionalInfo !== "" &&
      !state.summarizedAdditionalInfo.includes("NO-CHANGE")
    ) {
      const id = `res-${Date.now()}`;
      const userInteractionPromise = new Promise<KaiUserInteractionMessage>((resolve, reject) => {
        this.userInteractionPromises.set(id, {
          resolve,
          reject,
        });
      });
      this.emitWorkflowMessage({
        id,
        type: KaiWorkflowMessageType.UserInteraction,
        data: {
          type: "yesNo",
          systemMessage: {
            yesNo:
              "We found more issues that we think we can fix. Do you want me to continue fixing those?",
          },
        },
      });
      try {
        const userResponse = await userInteractionPromise;
        if (userResponse.data.response?.yesNo) {
          nextNode = "address_additional_information";
        }
      } catch (e) {
        console.log(`Failed to wait for user response - ${e}`);
      } finally {
        this.userInteractionPromises.delete(id);
      }
    }
    return nextNode;
  }

  // edge to process tool calls for additional info agent
  private runToolsAdditionalInfoEdge(state: typeof MessagesAnnotation.State) {
    const lastMessage = state.messages[state.messages.length - 1];
    if (lastMessage instanceof AIMessage || lastMessage instanceof AIMessageChunk) {
      return lastMessage.tool_calls && lastMessage.tool_calls.length > 0
        ? "run_tools_additional_info"
        : END;
    } else {
      return END;
    }
  }
}
