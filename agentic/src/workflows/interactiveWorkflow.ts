import { EnhancedIncident } from "@editor-extensions/shared";
import { AIMessage, AIMessageChunk } from "@langchain/core/messages";
import { Annotation, type MessagesAnnotation } from "@langchain/langgraph";
import { CompiledStateGraph, END, START, StateGraph } from "@langchain/langgraph";

import {
  KaiUserInteractionMessage,
  type PendingUserInteraction,
  type KaiWorkflow,
  type KaiWorkflowInitOptions,
  type KaiWorkflowInput,
  type KaiWorkflowMessage,
  type KaiWorkflowResponse,
  KaiWorkflowMessageType,
} from "../types";
import {
  SummarizeAdditionalInfoOutputState,
  AnalysisIssueFixOrchestratorState,
  SummarizeHistoryOutputState,
} from "../schemas/analysisIssueFix";
import { modelHealthCheck } from "../utils";
import { FileSystemTools } from "../tools/filesystem";
import { KaiWorkflowEventEmitter } from "../eventEmitter";
import { AnalysisIssueFix } from "../nodes/analysisIssueFix";
import { JavaDependencyTools } from "../tools/javaDependency";
import { DiagnosticsIssueFix } from "../nodes/diagnosticsIssueFix";
import { AgentName, DiagnosticsOrchestratorState } from "../schemas/diagnosticsIssueFix";

export interface KaiInteractiveWorkflowInput extends KaiWorkflowInput {
  programmingLanguage: string;
  migrationHint: string;
  // whether or not to enable addressing additional information (default false)
  enableAdditionalInformation?: boolean;
  // whether or not to enable addressing diagnostics issues (default false)
  enableDiagnostics?: boolean;
}

// output state of the initial analysis workflow
const AnalysisWorkflowOutputState = Annotation.Root({
  ...SummarizeAdditionalInfoOutputState.spec,
  ...SummarizeHistoryOutputState.spec,
});

// overall state of the initial analysis workflow
const AnalysisWorkflowOverallState = Annotation.Root({
  ...AnalysisIssueFixOrchestratorState.spec,
  ...AnalysisWorkflowOutputState.spec,
});

/**
 * Agentic workflow that takes a list of incidents as input
 * and fixes all incidents as well as addresses any additional
 * changes needed elsewhere in the project. The workflow works
 * as follows - first, it iterates over all incidents grouped
 * by files and generates fixes using the analysis fix node
 * second, it captures output generated by the analysis fix node
 * and passes it to summarize node that summarizes any further
 * changes needed. finally, the accumulated output are passed to
 * another workflow which - first, addresses any additional info
 * generated by first workflow. once all of the changes from it
 * are addressed, waits for the IDE to send in diagnostics. the
 * second workflow is interactive in that it asks for confirmation
 * from the user before starting agents on any new work
 */
export class KaiInteractiveWorkflow
  extends KaiWorkflowEventEmitter
  implements KaiWorkflow<KaiInteractiveWorkflowInput>
{
  // workflow that generates the initial fixes for analysis issues
  // spits out modified files and summary of changes & additional information
  private analysisFixWorkflow: CompiledStateGraph<any, any, any, any, any> | undefined;
  // workflow that starts after initial analysis fixes are done, it uses
  // additional info as starting input to make more changes, also waits
  // on diagnostics info to arrive from IDE to make any more changes afterwards
  private followUpInteractiveWorkflow:
    | CompiledStateGraph<any, any, string, any, any, any>
    | undefined;
  private diagnosticsNodes: DiagnosticsIssueFix | undefined;

  private userInteractionPromises: Map<string, PendingUserInteraction>;

  constructor() {
    super();
    this.diagnosticsNodes = undefined;
    this.analysisFixWorkflow = undefined;
    this.followUpInteractiveWorkflow = undefined;
    this.userInteractionPromises = new Map<string, PendingUserInteraction>();

    this.runToolsEdgeFunction = this.runToolsEdgeFunction.bind(this);
    this.analysisIssueFixRouterEdge = this.analysisIssueFixRouterEdge.bind(this);
    this.diagnosticsOrchestratorEdge = this.diagnosticsOrchestratorEdge.bind(this);
  }

  async init(options: KaiWorkflowInitOptions): Promise<void> {
    const workspaceDir = options.workspaceDir.replace("file://", "");
    const fsTools = new FileSystemTools(workspaceDir, options.fsCache);
    const depTools = new JavaDependencyTools();
    const { supportsTools, connected, supportsToolsInStreaming } = await modelHealthCheck(
      options.model,
    );
    if (!connected) {
      throw Error(`Provided model doesn't seem to have connection`);
    }
    const analysisIssueFixNodes = new AnalysisIssueFix(
      {
        model: options.model,
        toolsSupported: supportsTools,
        toolsSupportedInStreaming: supportsToolsInStreaming,
      },
      fsTools.all(),
      options.fsCache,
      workspaceDir,
    );
    // relay events from nodes back to callers
    analysisIssueFixNodes.on("workflowMessage", async (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });
    fsTools.on("workflowMessage", async (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });

    this.diagnosticsNodes = new DiagnosticsIssueFix(
      {
        model: options.model,
        toolsSupported: supportsTools,
        toolsSupportedInStreaming: supportsToolsInStreaming,
      },
      workspaceDir,
      fsTools.all(),
      depTools.all(),
      options.fsCache,
    );
    this.diagnosticsNodes.on("workflowMessage", async (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });

    this.analysisFixWorkflow = new StateGraph({
      input: AnalysisIssueFixOrchestratorState,
      output: AnalysisWorkflowOutputState,
      stateSchema: AnalysisWorkflowOverallState,
    })
      // router node that iterates through incidents by uris and fixes them one by one before moving on
      .addNode("fix_analysis_issue_router", analysisIssueFixNodes.fixAnalysisIssueRouter)
      // node responsible for fixing analysis issues in one file (low effort prompt)
      .addNode("fix_analysis_issue", analysisIssueFixNodes.fixAnalysisIssue)
      // node responsible for summarizing additional information spit by fix_analysis_issue
      .addNode(
        "summarize_additional_information",
        analysisIssueFixNodes.summarizeAdditionalInformation,
      )
      // node responsible for summarizing changes made by fix_analysis_issue to be used as background by planner
      .addNode("summarize_history", analysisIssueFixNodes.summarizeHistory)
      // start with router
      .addEdge(START, "fix_analysis_issue_router")
      // router loops over all incidents and decides when to go to additional info
      .addConditionalEdges("fix_analysis_issue_router", this.analysisIssueFixRouterEdge, [
        "fix_analysis_issue",
        "summarize_additional_information",
        "summarize_history",
        "fix_analysis_issue_router",
        END,
      ])
      // go back to router with response, router decides what to do next
      .addEdge("fix_analysis_issue", "fix_analysis_issue_router")
      .addEdge("summarize_additional_information", END)
      .addEdge("summarize_history", END)
      .compile();

    this.followUpInteractiveWorkflow = new StateGraph({
      input: DiagnosticsOrchestratorState,
      output: DiagnosticsOrchestratorState,
      stateSchema: DiagnosticsOrchestratorState,
    })
      // node that orchestrates planning and invoking of other agents
      .addNode("orchestrate_plan_and_execution", this.diagnosticsNodes.orchestratePlanAndExecution)
      // node that plans fixes and distributes work to specialized agents
      .addNode("plan_fixes", this.diagnosticsNodes.planFixes)
      // node that is responsible for fixing issues that don't have a specialized agent available for
      .addNode("fix_general_issues", this.diagnosticsNodes.fixGeneralIssues)
      // node responsible for fixing dependency issues
      .addNode("fix_java_dep_issues", this.diagnosticsNodes.fixJavaDependencyIssues)
      // node responsible for handling tool calls by the general agent
      .addNode("tools_fix_general_issues", this.diagnosticsNodes.runTools)
      // node responsible for handling tool calls by the dep agent
      .addNode("tools_fix_dep_issues", this.diagnosticsNodes.runTools)
      .addEdge("tools_fix_general_issues", "fix_general_issues")
      .addEdge("tools_fix_dep_issues", "fix_java_dep_issues")
      .addEdge("plan_fixes", "orchestrate_plan_and_execution")
      .addEdge(START, "orchestrate_plan_and_execution")
      .addConditionalEdges(
        "fix_general_issues",
        this.runToolsEdgeFunction("tools_fix_general_issues", "orchestrate_plan_and_execution"),
        ["tools_fix_general_issues", "orchestrate_plan_and_execution"],
      )
      .addConditionalEdges(
        "fix_java_dep_issues",
        this.runToolsEdgeFunction("tools_fix_dep_issues", "orchestrate_plan_and_execution"),
        ["tools_fix_dep_issues", "orchestrate_plan_and_execution"],
      )
      .addConditionalEdges("orchestrate_plan_and_execution", this.diagnosticsOrchestratorEdge, [
        "plan_fixes",
        "fix_java_dep_issues",
        "fix_general_issues",
        "orchestrate_plan_and_execution",
        END,
      ])
      .compile();
  }

  async run(input: KaiInteractiveWorkflowInput): Promise<KaiWorkflowResponse> {
    if (!this.analysisFixWorkflow || !(this.analysisFixWorkflow instanceof CompiledStateGraph)) {
      throw new Error(`Workflow must be inited before it can be run`);
    }

    const incidentsByUris: Array<{ uri: string; incidents: EnhancedIncident[] }> =
      input.incidents?.reduce(
        (acc, incident) => {
          const existingEntry = acc.find(
            (entry: { uri: string; incidents: EnhancedIncident[] }) =>
              entry.uri === incident.uri.replace("file://", ""),
          );
          if (existingEntry) {
            existingEntry.incidents.push(incident);
          } else {
            acc.push({
              uri: incident.uri.replace("file://", ""),
              incidents: [incident],
            });
          }
          return acc;
        },
        [] as Array<{ uri: string; incidents: EnhancedIncident[] }>,
      ) ?? [];

    const graphInput: typeof AnalysisIssueFixOrchestratorState.State = {
      inputIncidentsByUris: incidentsByUris,
      currentIdx: 0,
      migrationHint: input.migrationHint,
      programmingLanguage: input.programmingLanguage,
      enableAdditionalInformation: input.enableAdditionalInformation ?? false,
      // internal fields
      inputFileContent: undefined,
      inputFileUri: undefined,
      inputIncidentsDescription: undefined,
      inputAllAdditionalInfo: undefined,
      inputAllReasoning: undefined,
      inputAllModifiedFiles: [],
      outputAdditionalInfo: undefined,
      outputReasoning: undefined,
      outputUpdatedFile: undefined,
      outputUpdatedFileUri: undefined,
      outputAllResponses: [],
    };

    const runResponse: KaiWorkflowResponse = {
      errors: [],
      modified_files: [],
    };

    // first run the analysis fix workflow
    const analysisFixOutputState: typeof AnalysisWorkflowOutputState.State =
      await this.analysisFixWorkflow.invoke(graphInput, {
        recursionLimit: incidentsByUris.length * 2 + 10,
      });

    // if there is any additional information spit by analysis workflow, capture that
    const additionalInformation: string = analysisFixOutputState.summarizedAdditionalInfo;
    if (
      !input.enableAdditionalInformation ||
      additionalInformation.length < 1 ||
      additionalInformation.includes("NO-CHANGE")
    ) {
      return runResponse;
    } else {
      // wait for user confirmation
      const id = `req-${Date.now()}`;
      const userConfirmationPromise = new Promise<KaiUserInteractionMessage>((resolve, reject) => {
        this.userInteractionPromises.set(id, {
          resolve,
          reject,
        });
      });
      this.emitWorkflowMessage({
        id,
        type: KaiWorkflowMessageType.UserInteraction,
        data: {
          type: "yesNo",
          systemMessage: {
            yesNo: "I found more changes to address. Do you want me to continue fixing them?",
          },
        },
      });
      try {
        const response = await userConfirmationPromise;
        if (response.data.response && !(response.data.response.yesNo ?? false)) {
          return runResponse;
        }
      } catch (e) {
        console.log(`Failed to wait for user response - ${e}`);
        return runResponse;
      } finally {
        this.userInteractionPromises.delete(id);
      }
    }

    // run the interactive workflow for further issues
    const interactiveWorkflowInput: typeof DiagnosticsOrchestratorState.State = {
      inputSummarizedAdditionalInfo:
        (input.enableAdditionalInformation ?? false) ? additionalInformation : undefined,
      migrationHint: input.migrationHint,
      programmingLanguage: input.programmingLanguage,
      plannerInputAgents: ["generalFix", "javaDependency"],
      plannerInputBackground: analysisFixOutputState.summarizedHistory,
      enableDiagnosticsFixes: input.enableDiagnostics ?? false,
      // internal fields
      inputDiagnosticsTasks: undefined,
      currentAgent: undefined,
      currentTask: undefined,
      inputInstructionsForGeneralFix: undefined,
      inputUrisForGeneralFix: undefined,
      messages: [],
      outputModifiedFilesFromGeneralFix: undefined,
      plannerOutputNominatedAgents: undefined,
      plannerInputTasks: undefined,
      shouldEnd: false,
    };

    await this.followUpInteractiveWorkflow?.invoke(interactiveWorkflowInput, {
      // each state change is one iteration, keeping this really high
      // users can ask to stop at any point. fixing analysis issues in a file
      // followed by adding a dependency to the pom is roughly 10 iterations if
      // the agent can find the pom file in the first attempt
      recursionLimit: 3000,
    });

    return runResponse;
  }

  async resolveUserInteraction(response: KaiUserInteractionMessage): Promise<void> {
    // if the response has tasks, the diagnosis orchestrator node should handle it
    if (
      response.type === KaiWorkflowMessageType.UserInteraction &&
      response.data.type === "tasks"
    ) {
      await this.diagnosticsNodes?.resolveDiagnosticsPromise(response);
      return;
    }
    const promise = this.userInteractionPromises.get(response.id);
    if (!promise) {
      return;
    }
    const { data } = response;
    if (!data.response || (!data.response.choice && data.response.yesNo === undefined)) {
      promise.reject(Error(`Invalid response from user`));
    }
    promise.resolve(response);
  }

  // edge responsible for invoking analysis issue fix node until all issues
  // are resolved. when resolved, moves onto addressing additional information
  async analysisIssueFixRouterEdge(
    state: typeof AnalysisIssueFixOrchestratorState.State,
  ): Promise<string | string[]> {
    // if these attributes are available, router meant to solve the analysis issue
    if (state.inputFileContent && state.inputFileUri && state.inputIncidentsDescription) {
      return "fix_analysis_issue";
    }
    // if there was a response, router needs to accumulate it
    if (state.outputUpdatedFile && state.outputUpdatedFileUri) {
      return "fix_analysis_issue_router";
    }
    // if there were any errors earlier in the router, go back to router
    // this will make router pick up the next incident in list
    if (
      state.currentIdx < state.inputIncidentsByUris.length &&
      (!state.inputFileContent || !state.inputFileUri || !state.inputIncidentsDescription)
    ) {
      return "fix_analysis_issue_router";
    }
    // if the router accumulated all responses, we need to go to additional information
    if (state.enableAdditionalInformation) {
      if (state.inputAllAdditionalInfo && state.inputAllReasoning) {
        return ["summarize_additional_information", "summarize_history"];
      } else if (state.inputAllAdditionalInfo) {
        return "summarize_additional_information";
      }
    }
    return "END";
  }

  // edge for the orchestrator to delegate work to planner and sub-agents
  async diagnosticsOrchestratorEdge(
    state: typeof DiagnosticsOrchestratorState.State,
  ): Promise<string> {
    if (state.shouldEnd) {
      return END;
    }
    // if an agent is picked, we need to invoke it to do the next task
    if (state.currentAgent) {
      switch (state.currentAgent as AgentName) {
        case "generalFix":
          return "fix_general_issues";
        case "javaDependency":
          return "fix_java_dep_issues";
        default:
          return "orchestrate_plan_and_execution";
      }
    }
    // if there is a task, we need the planner to act on it
    if (state.currentTask) {
      return "plan_fixes";
    }
    return "orchestrate_plan_and_execution";
  }

  // generates an edge function to connect agent nodes with tool nodes and their orchestrator nodes
  // returnNode is the orchestrator
  private runToolsEdgeFunction(
    toolNode: string,
    returnNode: string,
  ): (state: typeof MessagesAnnotation.State) => Promise<string> {
    return async (state: typeof MessagesAnnotation.State): Promise<string> => {
      if (!state.messages) {
        return returnNode;
      }
      const lastMessage = state.messages[state.messages.length - 1];
      if (lastMessage instanceof AIMessage || lastMessage instanceof AIMessageChunk) {
        return lastMessage.tool_calls && lastMessage.tool_calls.length > 0 ? toolNode : returnNode;
      } else {
        return returnNode;
      }
    };
  }
}
